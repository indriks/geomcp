import { getEnvConfig } from '../config/env';
import { createContentMention } from '../db/client';
import { GITHUB_ORG } from '@geomcp/shared';

interface PublishOptions {
  repo: string;
  path: string;
  content: string;
  message: string;
  clientId: string;
  contentType: string;
  mentionType?: string;
  geoScore?: number;
}

interface GitHubFileResponse {
  content: {
    html_url: string;
    sha: string;
  };
}

export async function publishContent(options: PublishOptions): Promise<string> {
  const config = getEnvConfig();
  const { repo, path, content, message, clientId, contentType, mentionType, geoScore } = options;

  // Check if file exists (to get SHA for update)
  let sha: string | undefined;
  try {
    const existingFile = await fetch(
      `https://api.github.com/repos/${GITHUB_ORG}/${repo}/contents/${path}`,
      {
        headers: {
          Authorization: `Bearer ${config.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (existingFile.ok) {
      const data = await existingFile.json();
      sha = data.sha;
    }
  } catch {
    // File doesn't exist, will create new
  }

  // Create or update file
  const response = await fetch(
    `https://api.github.com/repos/${GITHUB_ORG}/${repo}/contents/${path}`,
    {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${config.githubToken}`,
        Accept: 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: `${message}\n\nAuto-generated by GEO MCP`,
        content: Buffer.from(content).toString('base64'),
        sha,
      }),
    }
  );

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error: ${error}`);
  }

  const data = (await response.json()) as GitHubFileResponse;
  const githubUrl = data.content.html_url;

  // Record the content mention
  await createContentMention({
    client_id: clientId,
    content_type: contentType,
    content_path: path,
    repo,
    mention_type: mentionType,
    github_url: githubUrl,
    geo_score: geoScore,
  });

  return githubUrl;
}

export async function getFileContent(repo: string, path: string): Promise<string | null> {
  const config = getEnvConfig();

  try {
    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_ORG}/${repo}/contents/${path}`,
      {
        headers: {
          Authorization: `Bearer ${config.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    return Buffer.from(data.content, 'base64').toString('utf-8');
  } catch {
    return null;
  }
}

export async function getLastCommitDate(repo: string, path: string): Promise<Date | null> {
  const config = getEnvConfig();

  try {
    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_ORG}/${repo}/commits?path=${path}&per_page=1`,
      {
        headers: {
          Authorization: `Bearer ${config.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) return null;

    const commits = await response.json();
    if (commits.length === 0) return null;

    return new Date(commits[0].commit.author.date);
  } catch {
    return null;
  }
}

export async function listRepoContents(
  repo: string,
  path: string = ''
): Promise<Array<{ name: string; path: string; type: string }>> {
  const config = getEnvConfig();

  try {
    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_ORG}/${repo}/contents/${path}`,
      {
        headers: {
          Authorization: `Bearer ${config.githubToken}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) return [];

    const data = await response.json();
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }
}
